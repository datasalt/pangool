---
layout: user_guide
title: Pangool - User guide - Group & Sort by
---
<div class="hero-unit">
	<h1>Pangool User Guide</h1>
</div>

<h1>Group-by & Order-by</h1>

<p>
Pangool was conceived to solve in a simple way how records emitted in the Map stage
are grouped and ordered when they reach the Reduce phase.
</p>
<p>
Pangool allows tuples be grouped by a subset of their fields. For instance:
</p>

<p>
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("my_schema",Fields.parse("url:string, timestamp:long")));
 b.setGroupByFields(“url”);
</pre>
</p>

<p>
In the example above tuples containing a <code>url</code> and <code>timestamp</code> arrive to the 
<i>Reduce</i> stage grouped by <code>url</code>.<br>
This is a trivial case which can be easily achieved by using plain MapReduce, 
but let's complicate things a bit more..
</p>

<p>
Let's say that you want tuples to be ordered in descending "url" order. In Pangool this is as easy 
as adding:
</p>

<p>
<pre class="prettyprint" id="java">
 b.setOrderBy(new OrderBy().add("url", Order.DESC))
</pre>
</p>

<p>
As shown above, just adding a new line allows us to define the criteria (ASC / DESC) used to sort tuples.<br>
This is apparently straight-forward, however plain MapReduce usually forces you to 
specify custom comparators to perform this simple task.
</p>

<p>
Let's complicate things further. Imagine that you still want to group tuples
by their <code>url</code> but you also need them be ordered by descending <code>timestamp</code>
for each group.<br> 
In this case the ordering criteria contains the fields <code>url</code> and <code>timestamp</code> which
exceed those that we defined in "group by" (<code>url</code>).
</p>
<p>
This way of ordering is called <b>Secondary Order</b> and it's achieved easily in Pangool by adding:
</p>

<p>
<pre class="prettyprint" id="java">
 b.setGroupByFields("url");
 b.setOrderBy(new OrderBy().add("url",Order.DESC).add("timestamp",Order.DESC))
</pre>
</p>

<p>
As shown in the snippet above, the fields defined in "order by" include those in "group by". This is a restriction 
in Pangool, where <i>Group-By</i> <b>must be a prefix</b> of <i>Order-By</i>.
</p>
Contrary to what it looks, this is tough to achieve in plain Map-Reduce, especially when  
several fields are involved in grouping and ordering. <br>Programming in plain 
Map-Reduce usually forces you to define custom logic for binary comparison, grouping and partitioning.<br> 
Pangool excels in this task, removing all this burden and offering it to you with no pain.
</p>


<div class="alert alert-info">
<p><b>Note:</b>
The partitioning strategy that Pangool chooses is coherent with the group-by / sort-by criterias.<br>
In this case, Pangool will partition by the Group-by fields unless we modify the default 
partitioning strategy. See the <a href="partitioner.html">Custom Partitioners</a> section for more about this.
</p>

</div>

<h2>Multi-schema Sort-By</h2>

<p>
When multiple intermediate schemas are defined and a Reduce-side Join is performed 
(see <a href="joins.html">joins</a> section) then Sort-By shows us more options and advanced 
features. <br>Let's see the next example:
</p>

<p>
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register",Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map",Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
</pre>
</p>

<p>
Usually when performing Joins the desired behavior is to receive one data type before the 
other.<br>
This eases programming and avoids having to keep data in memory before performing the actual
join business logic. (For instance, in a Cross-Product)<br>
In Pangool this is achieved adding this:
</p>

<pre class="prettyprint" id="java">
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url", Order.ASC).addSchemaOrder(Order.DESC)));
</pre>

<p>
The special method <code>addSchemaOrder</code> in <code>OrderBy</code> indicates that 
tuples, after being ordered by <code>url</code>, they will be ordered according to the schema they belong.<br>
That is, given the dataset below: 
</p>
<p>
<pre class="prettyprint" id="java">
 URLS_REGISTERS:
 { "url1.com", 10000 }
 { "url2.com", 20000 } 
 { "url1.com", 30000 } 
 { "url2.com", 40000 }
 { "url1.com", 20000 }  
 
 URLS_MAPS:
 { "url1.com", "http://canonical_url1.com" }
 { "url2.com", "http://canonical_url2.com" } 
 </pre>
</p>

<p>
According to the definition above :
<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register",Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map",Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url",Order.ASC).addSchemaOrder(Order.DESC)));
</pre>

Tuples will be received in the Reduce phase in the following way:
</p>

<pre class="prettyprint" id="java">
 REDUCE_GROUP_1 ("url1.com"):
 { "url1.com", "http://canonical_url1.com" }
 { "url1.com", 10000 }
 { "url1.com", 30000 }
 { "url1.com", 20000 } 

 REDUCE_GROUP_2 ("url2.com"):   
 { "url2.com", "http://canonical_url2.com" }
 { "url2.com", 20000 }
 { "url2.com", 40000 }
 </pre>
 
<p>
Receiving the <code>canonical_url</code> first allows us to process
the remaining urls without needing to keep them in memory (or spilling them to disk).  
</p>

<div class="alert alert-info">
<p><b>Note:</b>
Any field used in <code>setOrderBy</code> must be present in every intermediate schema defined with the same name <strong>and</strong> type.
</p>
</div>

<h2>Specific Order-By</h2>

<p>
In some cases, when performing a Reduce-side join, we could be interested in ordering tuples within a particular schema in
a specific criteria.<br> This is achieved by using the method <code>setSpecificOrderBy</code>.<br>
We can reuse the previous example to specify a particular ordering for the tuples from <code>urls_register</code>:
</p>

<pre class="prettyprint" id="java">
 TupleMRBuilder b = new TupleMRBuilder();
 b.addIntermediateSchema(new Schema("urls_register", Fields.parse("url:string,timestamp:long")));
 b.addIntermediateSchema(new Schema("urls_map", Fields.parse("url:string,canonical_url:string")));
 b.setGroupByFields(“url”);
 b.setOrderBy(new OrderBy().add("url", Order.ASC).addSchemaOrder(Order.DESC)));
 b.setSpecificOrderBy("urls_register", new OrderBy().add("timestamp", Order.DESC));
</pre>
 
<p>
Given the previous input dataset, the output would be :
</p> 

<pre class="prettyprint" id="java">
 REDUCE_GROUP_1 ("url1.com"):
 { "url1.com", "http://canonical_url1.com" }
 { "url1.com", 30000 }
 { "url1.com", 20000 }
 { "url1.com", 10000 } 

 REDUCE_GROUP_2 ("url2.com"):   
 { "url2.com", "http://canonical_url2.com" }
 { "url2.com", 40000 }
 { "url2.com", 20000 }
</pre>

<p>
Note how tuples from "urls_register" now come sorted by timestamp.
</p>
 
<p><a class="btn btn-primary btn-large" href="named_outputs.html">Next: Named outputs &raquo;</a></p>